<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>temp</title>
	<script src="jquery-3.3.1.js"></script>
	<script src="d3.v5.js"></script>
	<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<svg>
</svg>
<div>
	<label>待查询的域名: </label>
	<input id="inputQueryDomain" type="text" placeholder="sec.cuc.edu.cn">
	<br>
	<label>指定名称服务器IP(可选): </label>
	<input id="inputDnsServerIp" type="text">
	<br>
	<button id="btnQuery" onclick="btnQueryOnclick()">查询</button>
	<label id="lbHint"></label>
</div>
</body>
<script>
	/* 常参数定义 */
	const svgWidth = 1950 / 2;
	const svgHeight = 910 / 2;
	const timerInterval = 10;
	const changeRate = 0.01;
	const arrowHeadHeight = 3;
	
	/* 全局变量 */
	let isLogic = false;
	
	/* 定义全局计时器 */
	let timerUpdates = [];
	setInterval(() => {
		timerUpdates.forEach((func) => func())
	}, timerInterval);
	
	/* 初始化svg画布 */
	const svg = d3.select("body").select("svg")
		.attr('width', svgWidth)
		.attr('height', svgHeight);
	const defs = svg.append('defs');
	defs.append('marker')
		.attr('id', 'end-arrow')
		.attr('viewBox', '0 -5 10 10')
		.attr('refX', 6)
		.attr('markerWidth', 3)
		.attr('markerHeight', arrowHeadHeight)
		.attr('orient', 'auto')
		.append('path')
		.attr('d', 'M0,-5L10,0L0,5')
		.attr('fill', '#000');
	
	let allPath = svg.append("g").selectAll("path");
	let allNode = svg.append("g").selectAll("g");
	let allText = allNode.append("text");
	let allCircle = allNode.append("circle");
	
	timerUpdates.push(() => {
		/* 根据变化率计算各属性的新值 */
		nodeDataset.forEach((d) => {
			d.targetX = isLogic ? d.logicX : d.physicalX;
			d.targetY = isLogic ? d.logicY : d.physicalY;
			d.currentX += changeRate * (d.logicX - d.currentX);
			d.currentY += changeRate * (d.logicY - d.currentY);
			d.currentR += changeRate * (d.targetR - d.currentR);
			d.currentOpacity += changeRate * (d.targetOpacity - d.currentOpacity);
		});
		
		/* 应用计算结果 */
		allNode.attr("transform", (d) => `translate(${d.currentX},${d.currentY})`);
		allNode.attr("opacity", (d) => d.currentOpacity);
		allNode.selectAll("circle").attr("r", (d) => d.currentR);
		allNode.selectAll("text").attr("opacity", (d) => d.currentOpacity);
		
		allPath
			.attr("d", (d) => {
				const deltaX = d.target.currentX - d.source.currentX;
				const deltaY = d.target.currentY - d.source.currentY;
				const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY) + 1;
				const normX = deltaX / dist;
				const normY = deltaY / dist;
				const sourcePadding = d.source.currentR;
				const targetPadding = d.target.currentR + arrowHeadHeight;
				const sourceX = d.source.currentX + (sourcePadding * normX);
				const sourceY = d.source.currentY + (sourcePadding * normY);
				const targetX = d.target.currentX - (targetPadding * normX);
				const targetY = d.target.currentY - (targetPadding * normY);
				
				return `M${sourceX},${sourceY}L${targetX},${targetY}`;
			})
			.attr("opacity", (d) => d.source.currentOpacity * d.target.currentOpacity)
		;
	});
	
	let nodeDataset = [];
	let pathDataset = [];
	
	function update() {
		/* node部分 */
		allNode = allNode
			.data(nodeDataset);
		allNode.exit().remove();
		
		let newNode = allNode.enter().append("g");
		allCircle = newNode.append("circle")
			.attr("class", "node")
			.style("fill", (d) => d.color)
			.merge(allCircle)
		;
		allText = newNode.append("text")
			.attr("x", 0)
			.attr("y", 4)
			.attr("class", "id")
			.text((d) => d.text)
			.style("text-anchor", "middle")
			.merge(allText)
		;
		
		allNode = allNode.merge(newNode);
		
		/* path部分 */
		pathDataset = [];
		for (let i = 0; i < nodeDataset.length - 1; ++i) {
			for (let j = i+1; j < nodeDataset.length; ++j) {
				let nodeDataA = nodeDataset[i], nodeDataB = nodeDataset[j];
				if(nodeDataA.isChosen && nodeDataA.level + 1 === nodeDataB.level) {
					pathDataset.push({source: nodeDataset[i], target: nodeDataset[j]});
				}
			}
		}
		allPath = allPath
			.data(pathDataset);
		allPath.exit().remove();
		allPath = allPath.enter().append('svg:path')
			.attr("class", "link")
			.style('marker-end', 'url(#end-arrow)')
			.merge(allPath);
	}
	
	function plus(strText, intLevel, intIndex, isChosen) {
		let data ={
			level: intLevel,
			currentX: Math.floor(Math.random() * svgWidth),
			currentY: Math.floor(Math.random() * svgHeight),
			logicX: 100 + 150 * intLevel,
			logicY: 50 + 30 * intIndex,
			currentR: 0,
			targetR: 10,
			currentOpacity: 0,
			targetOpacity: 1,
			text: strText,
			isChosen: isChosen,
			color: isChosen ? "red" : "gray"
		};
		nodeDataset.push(data);
		update();
	}
	
</script>
<script>
	function checkQueryDomain(domain) {
		/* 检查除最后一个part外域名中其他part是否包含空字符串 */
		let isOk = true;
		let parts = domain.split(".");
		for (let i = 0; i < parts.length - 1; ++i) {
			if (parts[i] === "") {
				isOk = false;
				break;
			}
		}
		return isOk;
	}
	
	function checkQueryRv(rv) {
		let isOk = true;
		if (rv.type === "FAIL") {
			isOk = false;
			// To do: 错误处理
			console.error(rv);
		}
		return isOk;
	}
	
	function query(strDomain, strDnsServer, strQueryType, callback) {
		let url = "/api/query?qname=" + strDomain + "&dns_server=" + strDnsServer + "&qtype=" + strQueryType;
		$.getJSON(url, callback);
	}
	
	function btnQueryOnclick() {
		/* 重置svg */
		allNode.remove();
		allPath.remove();
		
		/* 获取参数 */
		let inputQueryDomain = $("#inputQueryDomain");
		let inputDnsServerIp = $("#inputDnsServerIp");
		let strQueryDomain = inputQueryDomain.val() || inputQueryDomain.attr("placeholder");
		let strDnsServerIp = inputDnsServerIp.val();
		
		if (!checkQueryDomain(strQueryDomain)) {
			// To do: 错误提示
			console.error("无效的域名:", strQueryDomain);
			return;
		}
		
		let intStepCount = 0;
		let answers = [];
		let answer = "";
		let strDnsServerDomain = "";
		let arrDnsServerIpWithGeo = "";
		
		plus(strDnsServerIp || "本地DNS服务器", intStepCount, 0, true);
		
		/* Step 1 查询根域名NS记录 */
		query(".", strDnsServerIp, "NS", (rv) => {
			intStepCount += 1;
			console.log("Step", intStepCount, "rv:", rv);
			if (!checkQueryRv(rv)) return;
			
			answers = rv.answers;
			answer = chooseRandomItem(answers);
			strDnsServerDomain = answer[0];
			arrDnsServerIpWithGeo = chooseRandomItem(answer[1]);
			strDnsServerIp = arrDnsServerIpWithGeo[0];
			answers.forEach((ans, i) => {
				plus(ans[0], intStepCount, i, ans[0] === strDnsServerDomain);
			});
			
			
			/* Step 2 查询顶级域名NS记录 */
			let parts = strQueryDomain.split('.');
			let strTopDomain = parts[parts.length - (parts[parts.length - 1] === "" ? 2 : 1)] + ".";
			query(strTopDomain, strDnsServerIp, "NS", (rv) => {
				intStepCount += 1;
				console.log("Step", intStepCount, "rv:", rv);
				if (!checkQueryRv(rv)) return;
				
				answers = rv.answers;
				answer = chooseRandomItem(answers);
				strDnsServerDomain = answer[0];
				arrDnsServerIpWithGeo = chooseRandomItem(answer[1]);
				strDnsServerIp = arrDnsServerIpWithGeo[0];
				answers.forEach((ans, i) => {
					plus(ans[0], intStepCount, i, ans[0] === strDnsServerDomain);
				});
				
				/* Step 3 循环查询主机名A记录 */
				function loopBody(rv) {
					intStepCount += 1;
					console.log("Step", intStepCount, "rv:", rv);
					if (!checkQueryRv(rv)) return;
					
					if(rv.type === "NS") {
						answers = rv.answers;
						answer = chooseRandomItem(answers);
						strDnsServerDomain = answer[0];
						arrDnsServerIpWithGeo = chooseRandomItem(answer[1]);
						strDnsServerIp = arrDnsServerIpWithGeo[0];
						answers.forEach((ans, i) => {
							plus(ans[0], intStepCount, i, ans[0] === strDnsServerDomain);
						});
						
						query(strQueryDomain, strDnsServerIp, "A", loopBody);
					}
					else{
						let strAnswer = chooseRandomItem(rv.answers);
						console.log("found", rv.type, "record", strAnswer);
					}
				}
				query(strQueryDomain, strDnsServerIp, "A", loopBody);
			})
		});
	}
</script>
<script>
	function chooseRandomItem(items) {
		return items[Math.floor(Math.random() * items.length)];
	}
</script>
</html>

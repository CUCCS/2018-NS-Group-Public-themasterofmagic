<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>temp</title>
	<script src="jquery-3.3.1.js"></script>
	<script src="d3.v5.js"></script>
	<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<svg>
</svg>
<div>
	<label>待查询的域名: </label>
	<input id="inputQueryDomain" type="text" placeholder="sec.cuc.edu.cn">
	<br>
	<label>指定名称服务器IP(可选): <input id="inputDnsServerIp" type="text"></label>
	<br>
	<button id="btnQuery" onclick="btnQueryOnclick()">查询</button>
	<label id="lbHint"></label>
	<br>
	<button onclick="isLogic=true; applyIsLogic()">逻辑视图</button>
	<button onclick="isLogic=false; applyIsLogic()">物理视图</button>
</div>
</body>
<script>
	/* 常参数定义 */
	const svgWidth = 1950 / 2;
	const svgHeight = 910 / 2;
	const timerInterval = 10;
	const changeRate = 0.01;
	const arrowHeadHeight = 5;
	const imgWidth = 1950;
	const imgHeight = 910;
	const imgPadding = {'T': 50, 'B': 35, 'L': 20, 'R': 20};
	const logicR = 10, physicalR = 10;
	const logicTextOpacity = 1, physicalTextOpacity = 0;
	
	/* 全局变量 */
	let isLogic = true;
	let rectOpacity = !isLogic;
	
	/* 定义全局计时器 */
	let timerUpdates = [];
	setInterval(() => {
		timerUpdates.forEach((func) => func())
	}, timerInterval);
	
	/* 初始化svg画布 */
	const svg = d3.select("body").select("svg")
		.attr('width', svgWidth)
		.attr('height', svgHeight);
	const defs = svg.append('defs');
	defs.append('marker')
		.attr('id', 'end-arrow')
		.attr('viewBox', '0 -5 10 10')
		.attr('refX', 6)
		.attr('markerWidth', 5)
		.attr('markerHeight', arrowHeadHeight)
		.attr('orient', 'auto')
		.append('path')
		.attr('d', 'M0,-5L10,0L0,5')
		.attr('fill', '#000');
	defs
		.append("pattern")
		.attr("id", "bg")
		.attr('width', svgWidth)
		.attr('height', svgHeight)
		.attr('patternUnits', 'userSpaceOnUse')
		.append("image")
		.attr("xlink:href", "world_map_small.jpg")
		.attr('width', svgWidth)
		.attr('height', svgHeight);
	const rect = svg.append('rect')
		.attr('fill', 'url(#bg)')
		.attr('width', svgWidth)
		.attr('height', svgHeight)
		.attr('opacity', rectOpacity);
	
	let allPath = svg.append("g").selectAll("path");
	let allNode = svg.append("g").selectAll("g");
	let allText = allNode.append("text");
	let allCircle = allNode.append("circle");
	
	timerUpdates.push(() => {
		/* 根据变化率计算各属性的新值 */
		nodeDataset.forEach((d) => {
			d.currentX += changeRate * (d.targetX - d.currentX);
			d.currentY += changeRate * (d.targetY - d.currentY);
			d.currentR += Math.pow(changeRate, 0.9) * (d.targetR - d.currentR);
			d.currentNodeOpacity += Math.pow(changeRate, 1) * (d.targetNodeOpacity - d.currentNodeOpacity);
			d.currentTextOpacity += changeRate * (d.targetTextOpacity - d.currentTextOpacity);
		});
		rectOpacity += changeRate * (!isLogic - rectOpacity);
		
		/* 应用计算结果 */
		allNode.attr("transform", (d) => `translate(${d.currentX},${d.currentY})`);
		allNode.attr("opacity", (d) => d.currentNodeOpacity);
		allNode.selectAll("circle").attr("r", (d) => d.currentR);
		allNode.selectAll("text").attr("opacity", (d) => d.currentNodeOpacity);
		allPath
			.attr("d", (d) => {
				const deltaX = d.target.currentX - d.source.currentX;
				const deltaY = d.target.currentY - d.source.currentY;
				const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY) + 1;
				const normX = deltaX / dist;
				const normY = deltaY / dist;
				const sourcePadding = d.source.currentR;
				const targetPadding = d.target.currentR + arrowHeadHeight;
				const sourceX = d.source.currentX + (sourcePadding * normX);
				const sourceY = d.source.currentY + (sourcePadding * normY);
				const targetX = d.target.currentX - (targetPadding * normX);
				const targetY = d.target.currentY - (targetPadding * normY);
				
				return `M${sourceX},${sourceY}L${targetX},${targetY}`;
			})
			.attr("opacity", (d) => d.source.currentNodeOpacity * d.target.currentNodeOpacity)
		;
		allText.attr("opacity", (d) => d.currentTextOpacity);
		allCircle.style("fill", (d) => d.color);
		rect.attr("opacity", rectOpacity);
	});
	
	let nodeDataset = [];
	let pathDataset = [];
	
	function setTarget(d) {
		if (isLogic) {
			d.targetX = d.logicX;
			d.targetY = d.logicY;
			d.targetR = logicR;
			d.targetNodeOpacity = 1;
			d.targetTextOpacity = logicTextOpacity;
		}
		else {
			let pos = geoToSvgPos(d.longitude, d.latitude);
			d.targetX = pos[0];
			d.targetY = pos[1];
			d.targetR = physicalR;
			d.targetNodeOpacity = d.isChosen || d.isStub ? 1 : 0;
			d.targetTextOpacity = physicalTextOpacity;
		}
	}
	
	function applyIsLogic() {
		nodeDataset.forEach((d) => {
			setTarget(d);
		})
	}
	
	function update() {
		/* node部分 */
		allNode = allNode
			.data(nodeDataset);
		allNode.exit().remove();
		
		let newNode = allNode.enter().append("g")
			.on("click", (d) => {
				if (!d.isChosen) {
					d.isStub = !d.isStub;
					d.color = d.isStub ? "red" : "gray"
				}
			})
			.on("mouseover", (d) => {
				d.targetR = 50;
			})
			.on("mouseout", (d) => {
				d.targetR = 10;
			})
		;
		allCircle = newNode.append("circle")
			.attr("class", "node")
			.merge(allCircle)
		;
		allText = newNode.append("text")
			.attr("x", 0)
			.attr("y", 4)
			.text((d) => d.text)
			.style("text-anchor", "middle")
			.merge(allText)
		;
		allNode = allNode.merge(newNode);
		allNode.filter((d) => d.isChosen).bringElementAsTopLayer();
		
		/* path部分 */
		pathDataset = [];
		for (let i = 0; i < nodeDataset.length - 1; ++i) {
			for (let j = i+1; j < nodeDataset.length; ++j) {
				let nodeDataA = nodeDataset[i], nodeDataB = nodeDataset[j];
				if(nodeDataA.isChosen && nodeDataA.level + 1 === nodeDataB.level) {
					pathDataset.push({source: nodeDataset[i], target: nodeDataset[j]});
				}
			}
		}
		allPath = allPath
			.data(pathDataset);
		allPath.exit().remove();
		allPath = allPath.enter().append('svg:path')
			.attr("class", "link")
			.style('marker-end', 'url(#end-arrow)')
			.merge(allPath);
	}
	
	function plus(strText, intLevel, intIndex, isChosen, geo) {
		let d ={
			level: intLevel,
			longitude: geo[0],
			latitude: geo[1],
			logicX: 100 + 150 * intLevel,
			logicY: 50 + 30 * intIndex,
			currentR: 100,
			targetR: 10,
			currentNodeOpacity: 0,
			targetNodeOpacity: 1,
			text: strText,
			isChosen: isChosen,
			isStub: false,
			color: isChosen ? "green" : "gray"
		};
		setTarget(d);
		d.currentX = d.targetX;
		d.currentY = d.targetY;
		d.currentTextOpacity = d.targetTextOpacity;
		nodeDataset.push(d);
		update();
	}
	
</script>
<script>
	function checkQueryDomain(domain) {
		/* 检查除最后一个part外域名中其他part是否包含空字符串 */
		let isOk = true;
		let parts = domain.split(".");
		for (let i = 0; i < parts.length - 1; ++i) {
			if (parts[i] === "") {
				isOk = false;
				break;
			}
		}
		return isOk;
	}
	
	function checkQueryRv(rv) {
		let isOk = true;
		if (rv.type === "FAIL") {
			isOk = false;
			// To do: 错误处理
			console.error(rv);
		}
		return isOk;
	}
	
	function query(strDomain, strDnsServer, strQueryType, callback) {
		let url = "/api/query?qname=" + strDomain + "&dns_server=" + strDnsServer + "&qtype=" + strQueryType;
		$.getJSON(url, callback);
	}
	
	function btnQueryOnclick() {
		/* 重置svg */
		nodeDataset = [];
		pathDataset = [];
		update();
		
		/* 获取参数 */
		let inputQueryDomain = $("#inputQueryDomain");
		let inputDnsServerIp = $("#inputDnsServerIp");
		let strQueryDomain = inputQueryDomain.val() || inputQueryDomain.attr("placeholder");
		let strDnsServerIp = inputDnsServerIp.val();
		
		if (!checkQueryDomain(strQueryDomain)) {
			// To do: 错误提示
			console.error("无效的域名:", strQueryDomain);
			return;
		}
		
		let intStepCount = 0;
		let answers = [];
		let answer = "";
		let strDnsServerDomain = "";
		let arrDnsServerIpWithGeo = "";
		
		plus(strDnsServerIp || "本地DNS服务器", intStepCount, 0, true, [0, 0]); // To do: 把0,0换成本地真实坐标
		
		/* Step 1 查询根域名NS记录 */
		query(".", strDnsServerIp, "NS", (rv) => {
			intStepCount += 1;
			console.log("Step", intStepCount, "rv:", rv);
			if (!checkQueryRv(rv)) return;
			
			answers = rv.answers;
			answer = chooseRandomItem(answers);
			strDnsServerDomain = answer[0];
			arrDnsServerIpWithGeo = chooseRandomItem(answer[1]);
			strDnsServerIp = arrDnsServerIpWithGeo[0];
			answers.forEach((ans, i) => {
				plus(ans[0], intStepCount, i, ans[0] === strDnsServerDomain, chooseRandomItem(ans[1])[1]);
				
			});
			
			/* Step 2 查询顶级域名NS记录 */
			let parts = strQueryDomain.split('.');
			let strTopDomain = parts[parts.length - (parts[parts.length - 1] === "" ? 2 : 1)] + ".";
			query(strTopDomain, strDnsServerIp, "NS", (rv) => {
				intStepCount += 1;
				console.log("Step", intStepCount, "rv:", rv);
				if (!checkQueryRv(rv)) return;
				
				answers = rv.answers;
				answer = chooseRandomItem(answers);
				strDnsServerDomain = answer[0];
				arrDnsServerIpWithGeo = chooseRandomItem(answer[1]);
				strDnsServerIp = arrDnsServerIpWithGeo[0];
				answers.forEach((ans, i) => {
					plus(ans[0], intStepCount, i, ans[0] === strDnsServerDomain, chooseRandomItem(ans[1])[1]);
				});
				
				/* Step 3 循环查询主机名A记录 */
				function loopBody(rv) {
					intStepCount += 1;
					console.log("Step", intStepCount, "rv:", rv);
					if (!checkQueryRv(rv)) return;
					
					if(rv.type === "NS") {
						answers = rv.answers;
						answer = chooseRandomItem(answers);
						strDnsServerDomain = answer[0];
						arrDnsServerIpWithGeo = chooseRandomItem(answer[1]);
						strDnsServerIp = arrDnsServerIpWithGeo[0];
						answers.forEach((ans, i) => {
							plus(ans[0], intStepCount, i, ans[0] === strDnsServerDomain, chooseRandomItem(ans[1])[1]);
						});
						
						query(strQueryDomain, strDnsServerIp, "A", loopBody);
					}
					else{
						let strAnswer = chooseRandomItem(rv.answers);
						console.log("found", rv.type, "record", strAnswer);
					}
				}
				query(strQueryDomain, strDnsServerIp, "A", loopBody);
			})
		});
	}
</script>
<script>
	function chooseRandomItem(items) {
		return items[Math.floor(Math.random() * items.length)];
	}
	
	function geoToSvgPos(longitude, latitude) {
		let x = longitude;
		let y = latitude;
		
		/* geo to image */
		x = x / 360 + 0.5;
		y = (y / 180 + 0.5) * 180 / 150;
		x *= imgWidth - imgPadding['L'] - imgPadding['R'];
		y *= imgHeight - imgPadding['T'] - imgPadding['B'];
		x += imgPadding['L'];
		y += imgPadding['T'];
		
		/* image to svg */
		x *= svgWidth / imgWidth;
		y *= svgHeight / imgHeight;
		
		return [x, y];
	}
	
	d3.selection.prototype.bringElementAsTopLayer = function() {
		 return this.each(function(){
				 this.parentNode.appendChild(this);
		 });
	};
</script>
</html>
